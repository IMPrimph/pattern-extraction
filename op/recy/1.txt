eventdeposit(addressindexeduser,uintamount,intbalance);
eventwithdraw(addressindexeduser,uintamount,intbalance);
functionetheropt(uintexpiration_,stringunderlying_,uintmargin_,uintrealityid_,bytes32facthash_,addressethaddr_,int[]strikes_){
functiongetaccountid(addressuser)constantreturns(uint){
functiongetaccount(uintaccountid)constantreturns(address){
functionaddfunds(){
if(accountids[msg.sender]>0){
accounts[accountids[msg.sender]].capital+=int(msg.value);
accounts[accountids[msg.sender]].capital+=int(msg.value);
accounts[accountid].capital+=int(msg.value);
accountids[msg.sender]=accountid;
deposit(msg.sender,msg.value,accounts[accountids[msg.sender]].capital);
deposit(msg.sender,msg.value,accounts[accountids[msg.sender]].capital);
functionwithdrawfunds(uintamount){
functionwithdrawfunds(uintamount){
if(accountids[msg.sender]>0){
if(int(amount)<=getfunds(msg.sender,true)&&int(amount)>0){
accounts[accountids[msg.sender]].capital-=int(amount);
accounts[accountids[msg.sender]].capital-=int(amount);
msg.sender.call.value(amount)();
msg.sender.call.value(amount)();
msg.sender.call.value(amount)();
withdraw(msg.sender,amount,accounts[accountids[msg.sender]].capital);
withdraw(msg.sender,amount,accounts[accountids[msg.sender]].capital);
functiongetfunds(addressuser,boolonlyavailable)constantreturns(int){
functiongetfundsandavailable(addressuser)constantreturns(int,int){
functionmarketmaker(stringserver){
if(msg.value>0)throw;
if(marketmakerids[msg.sender]>0){
marketmakers[marketmakerids[msg.sender]].server=server;
marketmakerids[msg.sender]=marketmakerid;
functiongetmarketmakers()constantreturns(string,string,string,string,string,string){
functiongetmarketmakerfunds()constantreturns(int,int,int,int,int,int){
functiongetoptionchain()constantreturns(uint,string,uint,uint,bytes32,address){
functiongetmarket(addressuser)constantreturns(uint[],int[],int[],int[]){
functionexpire(uintaccountid,uint8v,bytes32r,bytes32s,bytes32value){
functionexpire(uintaccountid,uint8v,bytes32r,bytes32s,bytes32value){
if(ecrecover(sha3(facthash,value),v,r,s)==ethaddr){
intmoneyness=getmoneyness(options[optionid],uint(value),margin);
uintamounttosend=uint(accounts[accountid].capital+result);
accounts[accountid].user.call.value(amounttosend)();
accounts[accountid].user.call.value(amounttosend)();
functiongetmoneyness(intstrike,uintsettlement,uintmargin)constantreturns(int){
functionordermatchtest(uintoptionid,uintprice,intsize,uintorderid,uintblockexpires,addressaddr,addresssender,uintvalue,intmatchsize)constantreturns(bool){
functionordermatchtest(uintoptionid,uintprice,intsize,uintorderid,uintblockexpires,addressaddr,addresssender,uintvalue,intmatchsize)constantreturns(bool){
if(block.number<=blockexpires&&((size>0&&matchsize<0&&orderfills[sha3(optionid,price,size,orderid,blockexpires)]-matchsize<=size)||(size<0&&matchsize>0&&orderfills[sha3(optionid,price,size,orderid,blockexpires)]-matchsize>=size))&&getfunds(addr,false)+getmaxlossaftertrade(addr,optionid,-matchsize,matchsize*int(price))>0&&getfunds(sender,false)+int(value)+getmaxlossaftertrade(sender,optionid,matchsize,-matchsize*int(price))>0){
functionordermatch(uintoptionid,uintprice,intsize,uintorderid,uintblockexpires,addressaddr,uint8v,bytes32r,bytes32s,intmatchsize){
if(positions[msg.sender].hasposition==false){
positions[msg.sender].hasposition=true;
positions[msg.sender].positions[optionid]+=matchsize;
positions[msg.sender].cash-=matchsize*int(price);
functiongetmaxlossaftertrade(addressuser,uintoptionid,intpositionchange,intcashchange)constantreturns(int){
functionmoneysumatsettlement(addressuser,uintoptionid,intpositionchange,uintsettlement)internalreturns(int){
functionmin(uinta,uintb)constantreturns(uint){